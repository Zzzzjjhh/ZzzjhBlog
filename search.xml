<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Exception（异常）</title>
      <link href="/ZzzjhBlog/2025/03/31/Exception%EF%BC%88%E5%BC%82%E5%B8%B8%EF%BC%89/"/>
      <url>/ZzzjhBlog/2025/03/31/Exception%EF%BC%88%E5%BC%82%E5%B8%B8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="异常-Exception"><a href="#异常-Exception" class="headerlink" title="异常(Exception)"></a>异常(Exception)</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Java语言中，将程序执行中发生的不正常情况成为“异常”，（开发中逻辑和语法错误不是异常）<br>执行过程中所发生的异常事件可分为两类<br>1）<strong>Error（错误）</strong>：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：<strong>StackOverflowError[栈溢出]和OOM（out of memory），Error是严重错误，程序会崩溃</strong>。</p><p>2）<strong>Exception</strong>：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如空指针访问，试图读取不存在的文件，网络连接中断等等，<strong>Exception分为两大类：运行时异常和编译时异常。</strong></p><h2 id="异常体系图"><a href="#异常体系图" class="headerlink" title="异常体系图"></a>异常体系图</h2><table><thead><tr><th>层级关系</th><th>异常类型 &#x2F; 子类</th><th>说明</th></tr></thead><tbody><tr><td><code>Object</code></td><td>—</td><td>所有类的基类</td></tr><tr><td><code>Throwable</code></td><td>—</td><td>所有异常和错误的父类，分为 <code>Error</code>（错误）和 <code>Exception</code>（异常）两大类</td></tr><tr><td><strong><code>Error</code></strong></td><td><code>VirtualMachineError</code></td><td>JVM 相关错误，如：</td></tr><tr><td></td><td><code>StackOverflowError</code></td><td>栈溢出错误</td></tr><tr><td></td><td><code>OutOfMemoryError</code></td><td>内存溢出错误</td></tr><tr><td></td><td><code>InternalError</code></td><td>JVM 内部错误</td></tr><tr><td></td><td><code>AWTError</code></td><td>AWT 相关错误</td></tr><tr><td><strong><code>Exception</code></strong></td><td><code>IOException</code></td><td>输入输出异常，如：</td></tr><tr><td></td><td><code>EOFException</code></td><td>输入流结束异常</td></tr><tr><td></td><td><code>FileNotFoundException</code></td><td>文件未找到异常</td></tr><tr><td></td><td><code>SQLException</code></td><td>数据库操作异常</td></tr><tr><td></td><td><code>RuntimeException</code></td><td>运行时异常（程序逻辑问题），如：</td></tr><tr><td></td><td><code>NullPointerException</code></td><td>空指针异常</td></tr><tr><td></td><td><code>ArithmeticException</code></td><td>算术异常（如除零）</td></tr><tr><td></td><td><code>ArrayIndexOutOfBoundsException</code></td><td>数组越界异常</td></tr><tr><td></td><td><code>IllegalArgumentException</code></td><td>非法参数异常</td></tr></tbody></table><p>Throwable：有两个重要的子类：Exception（异常）和Error（错误），两者都包含了大量的异常处理类。Exception这种异常又分为两类：运行时异常和编译异常。</p><p>1、<strong>运行时异常(不受检异常)</strong>：RuntimeException类极其子类表示JVM在运行期间可能出现的错误。比如说试图使用<strong>空值对象的引用（NullPointerException）</strong>、<strong>数组下标越界（ArrayIndexOutBoundException）</strong>。此类异常属于不可查异常，一般是由程序逻辑错误引起的，<strong>在程序中可以选择捕获处理，也可以不处理。</strong></p><p>2、<strong>编译异常(受检异常)</strong>：Exception中除RuntimeException极其子类之外的异常。如果程序中出现此类异常，比如说<strong>IOException</strong>，<strong>必须对该异常进行处理，否则编译不通过</strong>。在程序中，通常不会自定义该类异常，而是直接使用系统提供的异常类。</p><h3 id="常见的运行时异常"><a href="#常见的运行时异常" class="headerlink" title="常见的运行时异常"></a>常见的运行时异常</h3><ol><li>NullPointerException<code> - 空指针异常，当应用程序试图在需要对象的地方使用</code>null&#96;时抛出。</li><li><code>ArithmeticException</code> - 数学运算异常，当出现异常的算术条件时，例如整数除以零时抛出。</li><li><code>ArrayIndexOutOfBoundsException</code> - 数组下标越界异常，当使用不合法的索引访问数组时抛出。</li><li><code>ClassCastException</code> - 类型转换异常，当试图将对象强制转换为不是实例的子类时抛出。</li><li><code>NumberFormatException</code> - 数字格式不正确异常，当应用程序试图将字符串转换为一种数值类型，但该字符串没有有效的格式时抛出。</li></ol><h3 id="常见的编译异常"><a href="#常见的编译异常" class="headerlink" title="常见的编译异常"></a>常见的编译异常</h3><ol><li><code>SQLException</code> - 操作数据库时，查询表可能发生异常。</li><li><code>IOException</code> - 操作文件时，发生的异常。</li><li><code>FileNotFoundException</code> - 当操作一个不存在的文件时，发生异常。</li><li><code>ClassNotFoundException</code> - 加载类时，而该类不存在时，发生的异常。</li><li><code>EOFException</code> - 操作文件时，到达文件末尾时，发生的异常。</li><li><code>IllegalArgumentException</code> - 参数异常，当传递给方法或构造函数的参数不合法或超出预期范围时，发生的异常。</li></ol><h2 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>异常处理就时异常发生的时候，对异常处理的方式</p><h3 id="异常处理的方式"><a href="#异常处理的方式" class="headerlink" title="异常处理的方式"></a>异常处理的方式</h3><h3 id="①try-catch、try-catch-finally"><a href="#①try-catch、try-catch-finally" class="headerlink" title="①try-catch、try-catch-finally"></a><strong>①try-catch、try-catch-finally</strong></h3><p>程序员在代码中捕获异常 自行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exception01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//代码有可能异常</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="comment">//捕获到的异常</span></span><br><span class="line">            <span class="comment">//1.当异常发生的时候 系统将异常封装成Exception对象e</span></span><br><span class="line">            <span class="comment">//2.得到异常对象后，程序员自己处理</span></span><br><span class="line">            <span class="comment">//如果没有发生异常catch中代码块不会执行</span></span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//1.不管代码快有没有异常 最后都会执行finally中的代码 </span></span><br><span class="line">            <span class="comment">//2.通常用来释放资源</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exception01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.如果try代码块可能有多个异常</span></span><br><span class="line">        <span class="comment">//2.可以使用多个catch 分别捕获不同异常 相应处理</span></span><br><span class="line">        <span class="comment">//3.要求子类异常写在前面，父类异常写在后面</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">            <span class="comment">//name 为null</span></span><br><span class="line">            System.out.println(person.name);</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a / b;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NullPointerException e)&#123; <span class="comment">//捕获空指针异常</span></span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123; <span class="comment">//捕获算数异常</span></span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;最后一定要运行的代码&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><strong>null</strong><br><strong>&#x2F;by zero</strong><br><strong>最后一定要运行的代码</strong></p><p><strong>练习</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exception01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String[] names = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>]; <span class="comment">// String数组</span></span><br><span class="line">            <span class="keyword">if</span> (names[<span class="number">1</span>].equals(<span class="string">&quot;tom&quot;</span>)) &#123; <span class="comment">// 这里会抛出NullPointerException，因为names[1]是null</span></span><br><span class="line">                System.out.println(names[<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                names[<span class="number">3</span>] = <span class="string">&quot;hspedu&quot;</span>; <span class="comment">// 这里会抛出ArrayIndexOutOfBoundsException，因为索引3超出范围</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123; <span class="comment">// 捕获NullPointerException</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 必须执行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>; <span class="comment">// 返回4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(method()); <span class="comment">//  输出什么？  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码执行流程：</p><ol><li><strong>进入 <code>try</code> 块</strong>：<ul><li><code>String[] names = new String[3];</code> 创建了一个长度为 3 的字符串数组，所有元素都被初始化为 <code>null</code>。</li><li>代码检查 <code>names[1].equals(&quot;tom&quot;)</code>，由于 <code>names[1]</code> 是 <code>null</code>，会抛出 <code>NullPointerException</code>。</li><li>程序跳到对应的 <code>catch (NullPointerException e)</code> 块。</li></ul></li><li><strong>进入 <code>NullPointerException</code> 的 <code>catch</code> 块</strong>：<ul><li>在 <code>catch (NullPointerException e)</code> 中，程序执行 <code>return 3;</code>，表示函数准备返回 3。</li><li>但在 <code>return 3;</code> 之前，程序会先执行 <code>finally</code> 块。</li></ul></li><li><strong>进入 <code>finally</code> 块</strong>：<ul><li><code>finally</code> 块中的 <code>return 4;</code> 强制函数返回 4，这会覆盖原本 <code>catch</code> 块中准备返回的值。</li></ul></li><li><strong>返回结果</strong>：<ul><li>无论之前 <code>try</code> 或 <code>catch</code> 块中执行了什么操作，由于 <code>finally</code> 块中有 <code>return 4;</code>，最终返回值都会是 4。</li></ul></li></ol><p><strong>练习二</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exception02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i++;<span class="comment">// i = 2</span></span><br><span class="line">            String[] names = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>]; <span class="comment">//创建String[] 数组 然后初始化为 null</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;tom&quot;</span>.equals(names[<span class="number">1</span>])) &#123;<span class="comment">//这里不会出现 空指针异常 因为 是 “tom“字符串调用的equals()方法</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                names[<span class="number">3</span>] = <span class="string">&quot;小黄人&quot;</span>;  <span class="comment">//数组越界异常 被越界异常捕获</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123; <span class="comment">//捕获数组越界异常</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">//由于有finally 不会返回</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> ++i;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123; <span class="comment">//必须执行</span></span><br><span class="line">            <span class="keyword">return</span> ++i; <span class="comment">// 执行 ++i  i的值为3 由于finally中有return 方法所以直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(method()); <span class="comment">// 输出3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：</span></span><br><span class="line"><span class="comment">// 1. names[1]是null，因此&quot;tom&quot;.equals(names[1])始终为false，执行else块。</span></span><br><span class="line"><span class="comment">// 2.因为 &quot;tom&quot; 是非 null 的字符串常量，所以调用 equals 时不会出错，即使 names[1] 是 null，它也只会返回 false，不会抛出异常。names[1].equals(&quot;tom&quot;)：如果 names[1] 是 null，则会抛出 NullPointerException，因为你试图对 null 对象调用方法。</span></span><br><span class="line"><span class="comment">// 3. names[3]是越界访问，将抛出ArrayIndexOutOfBoundsException。</span></span><br><span class="line"><span class="comment">// 4. 由于finally块中的return语句，其他所有return语句都将被忽略。</span></span><br><span class="line"><span class="comment">// 5. 最终，method()方法返回3。</span></span><br></pre></td></tr></table></figure><p>代码执行流程：</p><ol><li><strong>初始变量设置</strong>：<ul><li><code>int i = 1;</code>，即 <code>i</code> 初始值为 1。</li></ul></li><li><strong>进入 <code>try</code> 块</strong>：<ul><li><code>i++</code>，即 <code>i</code> 的值变为 2。</li><li><code>String[] names = new String[3];</code> 创建一个长度为 3 的字符串数组，所有元素都初始化为 <code>null</code>。</li><li><code>if (&quot;tom&quot;.equals(names[1]))</code>，由于 <code>names[1]</code> 为 <code>null</code>，因此 <code>equals</code> 比较时不会抛出 <code>NullPointerException</code>，而是返回 <code>false</code>（<code>&quot;tom&quot;.equals(null)</code> 为 <code>false</code>）。</li><li>程序进入 <code>else</code> 分支，执行 <code>names[3] = &quot;小黄人&quot;;</code>，但由于 <code>names</code> 的长度为 3，访问 <code>names[3]</code> 超出数组范围，抛出 <code>ArrayIndexOutOfBoundsException</code>。</li></ul></li><li><strong>进入 <code>ArrayIndexOutOfBoundsException</code> 的 <code>catch</code> 块</strong>：<ul><li>捕获数组越界异常，并执行 <code>return 2;</code>，表示准备返回 2。</li><li>但是由于有 <code>finally</code> 块，<code>return 2;</code> 会暂时被搁置，程序会继续执行 <code>finally</code> 块。</li></ul></li><li><strong>进入 <code>finally</code> 块</strong>：<ul><li><code>finally</code> 块中的 <code>return ++i;</code> 会再次执行 <code>++i</code>，此时 <code>i</code> 变为 3，并返回 3。</li><li>由于 <code>finally</code> 块中的 <code>return</code> 语句会覆盖其他所有的 <code>return</code>，因此最终返回值为 3。</li></ul></li></ol><p>总结：</p><ul><li><p><strong>最终输出结果</strong>：<code>method()</code> 方法的返回值是 3。</p></li><li><p>这是因为 <code>finally</code> 块中的 <code>return ++i;</code> 覆盖了 <code>try</code> 和 <code>catch</code> 块中的 <code>return</code> 语句。</p></li></ul><p><strong>练习三</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exception03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">            String[] names = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">if</span> (names[<span class="number">1</span>].equals(<span class="string">&quot;tom&quot;</span>)) &#123; <span class="comment">// 这里会抛出NullPointerException，因为names[1]是null</span></span><br><span class="line">                System.out.println(names[<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                names[<span class="number">3</span>] = <span class="string">&quot;小黄人&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123; <span class="comment">//捕获空指针异常</span></span><br><span class="line">            <span class="keyword">return</span> ++i; <span class="comment">//执行  ++i i = 3 由于最后有finally但是finally中没有return语句 所以 这里执行完++i之后 会有一个 临时变量 temp 保存了 i 的值 temp=&gt;3 然后去执行finally 然后等finally执行完之后 再回来执行return语句</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ++i; <span class="comment">//i = 4</span></span><br><span class="line">            System.out.println(<span class="string">&quot;i=&quot;</span> + i); <span class="comment">//输出 i = 4 由于没有 return  回到  捕获空指针异常中 然后返回的是temp临时变量的值;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(method()); <span class="comment">// 调用method方法并打印其返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：</span></span><br><span class="line"><span class="comment">// method()的实际返回值将取决于捕获到的异常类型，但由于finally块中的++i，最终的返回值可能会受到影响（但在这个特定代码中，由于return语句的位置，finally块中的修改不会影响返回值）。</span></span><br></pre></td></tr></table></figure><p><strong>代码执行流程</strong></p><ol><li><strong>初始变量设置</strong>：<ul><li><code>int i = 1;</code>，即 <code>i</code> 初始值为 1。</li></ul></li><li><strong>进入 <code>try</code> 块</strong>：<ul><li><code>i++</code>，即 <code>i</code> 的值变为 2。</li><li><code>String[] names = new String[3];</code>，声明一个长度为 3 的字符串数组，所有元素都初始化为 <code>null</code>。</li><li><code>if (names[1].equals(&quot;tom&quot;))</code>，此时 <code>names[1]</code> 依然为 <code>null</code>，因此会抛出 <code>NullPointerException</code>，程序跳转到对应的 <code>catch (NullPointerException e)</code> 块。</li></ul></li><li><strong>进入 <code>NullPointerException</code> 的 <code>catch</code> 块</strong>：<ul><li><code>++i</code>，即 <code>i</code> 从 2 变为 3。</li><li>然后准备返回 <code>i</code>，但由于有 <code>finally</code> 块，返回值暂时保存为一个临时变量 <code>temp</code>，<code>temp = 3</code>。</li></ul></li><li><strong>进入 <code>finally</code> 块</strong>：<ul><li><code>++i</code>，即 <code>i</code> 再次自增，变为 4。</li><li>打印输出 <code>&quot;i=4&quot;</code>，这是最后一步显示的内容。</li><li><code>finally</code> 块结束后，控制权返回到之前的 <code>catch</code> 块的 <code>return</code> 语句，但最终返回的是保存下来的 <code>temp</code> 值，即 3。</li></ul></li><li><strong>返回结果</strong>：<ul><li>因此，<code>method()</code> 方法的返回值是 3，而不是 <code>finally</code> 块中修改后的 <code>i</code> 值 4。<code>finally</code> 中对 <code>i</code> 的修改不会影响返回值，因为返回值在进入 <code>finally</code> 前已经确定。</li></ul></li></ol><p>总结：</p><p>需要注意的是 <code>finally</code> 修改了 <code>i</code> 但并不影响返回值。</p><p><strong>try-catch异常处理及try-catch-finally执行顺序小结：</strong>  </p><ol><li><p><strong>没有出现异常时</strong>：  </p><ul><li>执行try块中的所有语句。  </li><li>不执行catch块中的任何语句。  </li><li>如果存在finally块，则最后执行finally块中的所有语句。</li></ul></li><li><p><strong>出现异常时</strong>：  </p><ul><li>try块中异常发生的位置之后的所有语句将不再执行。  </li><li>执行与异常类型相匹配的catch块中的语句。  </li><li>如果有finally块，则在catch块（或try块直接结束后，如果没有匹配的catch块）执行完毕后，最后执行finally块中的所有语句。</li></ul></li></ol><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><p>如果用户输入的不是整数，就提示他反复的输入 直到输入正确为止 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionExe</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> number;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请输入整数&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">                number = Integer.parseInt(str);  <span class="comment">// 将输入的字符串转成整数</span></span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// 如果输入成功，跳出循环</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;  <span class="comment">// 只捕获数字格式异常</span></span><br><span class="line">                System.out.println(<span class="string">&quot;你需要输入整数&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(number);</span><br><span class="line">        scanner.close();  <span class="comment">// 关闭 Scanner</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="②throws"><a href="#②throws" class="headerlink" title="②throws"></a><strong>②throws</strong></h3><p>将发生的异常抛出，交给调用者（方法来处理），最顶级的处理者就是JVM</p><h4 id="throws处理机制图"><a href="#throws处理机制图" class="headerlink" title="throws处理机制图"></a>throws处理机制图</h4><table><thead><tr><th>步骤</th><th>处理单元</th><th>操作</th><th>异常传递说明</th></tr></thead><tbody><tr><td>1</td><td>f2 方法</td><td>抛出异常</td><td>f2 方法执行过程中触发异常，生成异常对象并抛出。</td></tr><tr><td>2</td><td>f1 方法</td><td>throws 声明异常</td><td>f1 方法通过<code>throws</code>声明承接 f2 抛出的异常，若自身未处理（无 try-catch），继续向上传递。</td></tr><tr><td>3</td><td>main 方法</td><td>throws 声明异常</td><td>main 方法通过<code>throws</code>接收 f1 传递的异常，若仍未处理（无 try-catch-finally），再次向上抛出。</td></tr><tr><td>4</td><td>JVM</td><td>最终处理异常</td><td>异常未被程序代码捕获处理，JVM 接收后执行默认操作（如终止程序、打印异常堆栈信息）。</td></tr></tbody></table><h4 id="throws异常处理-基本介绍"><a href="#throws异常处理-基本介绍" class="headerlink" title="throws异常处理,基本介绍"></a>throws异常处理,基本介绍</h4><p>1）如果一个方法（中的语句执行时）可能生成某种异常，但是并不能确定如何,处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些,异常进行处理，而由该方法的<strong>调用者负责处理</strong>。<br>2）在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异,常类型可以是方法中产生的异常类型，也可以是它的父类。</p><p>注意事项和使用细节,ThrovwsDetail.java<br>1）对于编译异常，程序中必须处理，比如try-catch或者throws<br>2）对于运行时异常，程序中<strong>如果没有处理，默认就是throws的方式处理</strong><br>3）子类重写父类的方法时，对抛出异常的规定：<strong>子类重写的方法，所抛出的异常类型要,么和父类抛出的异常一致，要么为父类抛出的异常的类型的子类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exception04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="comment">//子类重写父类的方法 对抛出异常的规定：子类的重写方法</span></span><br><span class="line">    <span class="comment">//抛出的异常类型要么和父类一致 要么是父类抛出异常的子类型 不然会报错</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）在throws过程中，<strong>如果有方法try-catch，就相当于处理异常，就可以不必,throws</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exception04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="comment">//因为f1（）方法调用f3（）方法 f3（）方法抛出了异常交给f1（）方法处理 所以 f1（）方法也要处理这个异常</span></span><br><span class="line">        <span class="comment">//可以try-catch 或者继续 throws 出去 如果有很多个方法这样嵌套 最终 异常会抛出到最开始的方法</span></span><br><span class="line">        f3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f3</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;<span class="comment">//抛出文件路径错误异常</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C://a.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>当程序出现某些”错误“ 但该错误信息并没有在Throwanle子类中描述处理，这个时候可以自己设计异常类用于描述该错误信息</p><h3 id="自定义异常步骤："><a href="#自定义异常步骤：" class="headerlink" title="自定义异常步骤："></a>自定义异常步骤：</h3><p>①定义类：自定义异常类名（程序员自己写）继承Exception或RuntiomeException<br>②如果继承Exception，属于编译异常<br>③如果继承RuntimeException，属于运行异常（一般来说继承RuntimeException）</p><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exception05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">80</span>;</span><br><span class="line">        <span class="comment">//要求在18 - 120之间 否则抛出一个自定义异常</span></span><br><span class="line">        <span class="keyword">if</span> (age &gt;= <span class="number">18</span> &amp;&amp; age &lt;= <span class="number">120</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;age 范围错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;你的年龄范围正确&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h3><table><thead><tr><th>关键字</th><th>意义</th><th>位置</th><th>后面跟的东西</th></tr></thead><tbody><tr><td>throws</td><td>异常处理的一种方式</td><td>方法声明处</td><td>异常类型</td></tr><tr><td>throw</td><td>手动生成异常对象的关键字</td><td>方法体中</td><td>异常对象</td></tr></tbody></table><p><strong>练习</strong><br>编写应用程序EcmDef.java 接受命令行的两个参数（整数类型）计算两数相除<br>计算两个数相除 要求使用方法cal（int n1，int n2）<br>对数据格式不正确 缺少命令行参数、除0 进行异常处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EcmDef</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(<span class="string">&quot;参数个数不对&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">            System.out.println(<span class="string">&quot;计算结果是：&quot;</span> +  cal(n1, n2));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;参数类型不对&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;出现了除0异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n1 / n2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内部类</title>
      <link href="/ZzzjhBlog/2025/03/31/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/ZzzjhBlog/2025/03/31/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>就是一个类中又完整的嵌套了另一个类的结构。被嵌套的类叫做内部类（inner class） 嵌套其他类的类称为外部类（outer class）<br><strong>拓展</strong><br>类的五大成员：<strong>属性、方法、构造器、代码块、内部类</strong><br><strong>内部类最主要的特点就是可以直接访问私有属性</strong></p><p>基本语法 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123; <span class="comment">//外部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span>&#123; <span class="comment">//内部类 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Other</span>&#123; <span class="comment">//外部其他类 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类的五要素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">//私有属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Outer</span><span class="params">(<span class="type">int</span> n1)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.n1 = n1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123; <span class="comment">//方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;m1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;<span class="comment">//代码块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Inner</span>&#123;<span class="comment">//内部类 在Outer内定义 </span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="内部类的类型（四种）"><a href="#内部类的类型（四种）" class="headerlink" title="内部类的类型（四种）"></a>内部类的类型（四种）</h2><p>定义在外部类的局部位置上（比如方法内）<br>①局部内部类（又类名）<br>②<strong>匿名内部类</strong>（<strong>没有类名</strong>，<strong>重点！！！</strong>）<br>定义在外部类的成员位置上：<br>③成员内部类（没用static 修饰）<br>④静态内部类（使用static 修饰）</p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>局部内部类是定义在外部类的局部位置，比如方法中，并且有类名<br>1.可以直接访问外部类的所有成员，包含私有的<br>2.不能添加访问修饰符，因为它的地位就是一个局部变量。局部变,修饰符的。<br>3.作用域：仅仅在定义它的方法或代码块中。<br>4.局部内部类—访问—-&gt;外部类的成员[访问方式：直接访问】<br>5.外部类—访问—-&gt;局部内部类的成员,访问方式：创建对象，再访问（注意：必须在作用域内）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalInnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        outer.m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">//属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123; <span class="comment">//</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Outer01 m2()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//局部内部类是定义在外部类的局部位置，通常在方法中</span></span><br><span class="line">        <span class="comment">//不能添加访问修饰符，但是可以用final修饰</span></span><br><span class="line">        <span class="comment">//作用域：仅仅在定义它的方法或代码块中 因为这个内部类就像相当于方法或代码块中的一个局部变量</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Inner01</span> &#123; <span class="comment">//局部内部类（本质上是一个类 类的五大成员都可以拥有 ）</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;n1=&quot;</span> + n1); <span class="comment">//可以直接访问外部类的所有成员包括私有的</span></span><br><span class="line">                m2();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//外部类在方法中可以创建Inner01对象，然后调用方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Inner01</span> <span class="variable">inner01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner01</span>();</span><br><span class="line">        inner01.f1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//n1=100</span></span><br><span class="line"><span class="comment">//Outer01 m2()</span></span><br></pre></td></tr></table></figure><p>记住：<br>（1）局部内部类定义在方法中或代码块中<br>（2）作用域在这个方法中或代码块中<br>（3）这个局部内部类本质就是一个类 包含类的五大成员</p><p><strong>外部</strong>其他类—不能访问—–&gt;局部内部类**（因为局部内部类相当于一个局部变量）</p><p>如果外部类和局部内部类的成员重名时候，默认遵守就近原则。如果想访问外部类的成员，则可以使用（<strong>外部类名.this.成员</strong>）<br>演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalInnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        outer.m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Outer01 m2()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Inner01</span> &#123;</span><br><span class="line">            <span class="comment">//此时内部类也有个 成员 n1 外部类也有成员n1</span></span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">800</span>;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">//那么此时访问的就是 内部类的n1 《遵守就近原则》 若想访问外部成员 n1 （外部类名.this.成员）</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Inner n1=&quot;</span> + n1); <span class="comment">//访问内部类的n1</span></span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;Outer n1=&quot;</span> + Outer.<span class="built_in">this</span>.n1);<span class="comment">//访问外部类的n1</span></span><br><span class="line">                <span class="comment">//Outer.this 这个本质就是外部类的一个对象 就是哪个对象调用 m1()方法就是哪个对象 我们在主方法中创建的 outer 对象调用了m1()方法 那么Outer.this就是outer对象</span></span><br><span class="line">                m2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Inner01</span> <span class="variable">inner01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner01</span>();</span><br><span class="line">        inner01.f1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="匿名内部类（！！！）"><a href="#匿名内部类（！！！）" class="headerlink" title="匿名内部类（！！！）"></a>匿名内部类（！！！）</h3><p>描述：</p><p>定义在外部类的局部位置 比如方法中 并且没有类名<br>（1）本质还是类<br>（2）内部类<br>（3）该类没有名字<br>（4）同时还是一个对象<br>（5）可以直接访问外部类的所有成员 包括私有的<br>（6）不能添加修饰符 因为它的地位就是一个局部变量<br>（7）作用域：仅仅在定义它的方法中或代码块中<br>（8）匿名内部类访问外部成员方式 【直接访问】<br>（9）外部其他类不能访问匿名内部类（因为匿名内部类地位就是一个局部变量）<br>（10）如果外部类和局部内部类的成员重名时候，默认遵守就近原则。如果想访问外部类的成员，则可以使用（<strong>外部类名.this.成员</strong>）</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类或接口(参数列表)&#123;</span><br><span class="line">    类体;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例子:</p><p><strong>基于接口创建匿名内部类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousInnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        outer.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123; <span class="comment">//外部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123; <span class="comment">//方法</span></span><br><span class="line">        <span class="comment">//基于接口的匿名内部类</span></span><br><span class="line">        <span class="comment">//需求 ： 想使用接口A，并且创建对象</span></span><br><span class="line">        <span class="comment">//传统方式：写一个类 实现该接口 并创建对象   接口名 变量名 = new 实现该接口的类的类名();</span></span><br><span class="line">        <span class="comment">//示例</span></span><br><span class="line">        <span class="comment">/*A tiger = new Tiger();</span></span><br><span class="line"><span class="comment">        tiger.cry();*/</span></span><br><span class="line">        <span class="comment">//如果你创建的类实现了该接口 但是只是用一次 后面不用了 这样定义一个类很麻烦</span></span><br><span class="line">        <span class="comment">//使用匿名内部类方式（简化开发）</span></span><br><span class="line">        <span class="comment">//示例</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">tiger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>() &#123;  <span class="comment">//一般来说接口是不能直接创建实例的  可是这里 相当于在Tiger类里面重写cry()方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;老虎在叫唤&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        tiger.cry();</span><br><span class="line">        System.out.println(<span class="string">&quot;tiger的运行类型等于&quot;</span> + tiger.getClass()); <span class="comment">//输出结果 Outer$1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时tiger 的编译类型是： A接口      运行类型是：匿名内部类 XXX 这个匿名内部类名称XXX是外部类名称 Outer加了一个$1 也就是 Outer$1</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">            底层中 会分配一个匿名  Outer$1</span></span><br><span class="line"><span class="comment">            是由 一个类 class Outer$1 implements A&#123;</span></span><br><span class="line"><span class="comment">                    <span class="doctag">@Override</span></span></span><br><span class="line"><span class="comment">                    public void cry() &#123;</span></span><br><span class="line"><span class="comment">                        System.out.println(&quot;老虎叫唤&quot;);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//同时jdk底层在创建匿名内部类后 立即创建了 创建了Outer$1实例，并且把地址返回给 tiger</span></span><br><span class="line">        <span class="comment">//匿名内部类使用一次 就不能在使用了 不是tiger 无法使用 而是 Outer$1这个类没有了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tiger</span> <span class="keyword">implements</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老虎叫唤&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123; <span class="comment">//接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>基于类创建匿名内部类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousInnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        outer.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123; <span class="comment">//外部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123; <span class="comment">//方法</span></span><br><span class="line">        <span class="comment">//基于类的匿名内部类</span></span><br><span class="line">        <span class="comment">//分析</span></span><br><span class="line">        <span class="comment">//1. father编译类型 Father</span></span><br><span class="line">        <span class="comment">//2. father运行类型 Outer$1</span></span><br><span class="line">        <span class="comment">//3.底层会创建匿名内部类</span></span><br><span class="line">        <span class="comment">//4.同时也直接返回了匿名内部类Outer$1的一个对象</span></span><br><span class="line">        <span class="comment">//5.注意(&#x27;jack&#x27;)参数列表回传给Father的构造器</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * class Outer$1 extends Father&#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public void test() &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(&quot;匿名内部类重写test方法&quot;);</span></span><br><span class="line"><span class="comment">              &#125;</span></span><br><span class="line"><span class="comment">         * &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>(<span class="string">&quot;jack&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类重写test方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//Father father1 = new Father(&quot;mack&quot;);</span></span><br><span class="line">        <span class="comment">//如果只是这样的化 那么它就只是单纯的创建一个Father的对象 编译类型和运行类型都是Father</span></span><br><span class="line">        System.out.println(<span class="string">&quot;father的运行类型是：&quot;</span> + father.getClass());</span><br><span class="line">        father.test();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.如果你是基于抽象类的匿名内部类就必须要重写这个抽象类的抽象方法</span></span><br><span class="line">        <span class="comment">//示例</span></span><br><span class="line">        <span class="comment">// 编译类型 Animal 运行类型 Outer$2</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;动物吃东西&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        animal.eat();</span><br><span class="line">        System.out.println(<span class="string">&quot;animal 运行类型&quot;</span> + animal.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;<span class="comment">//类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">(String name)</span> &#123; <span class="comment">//构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;接收到 name=&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;<span class="comment">//方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong><br><img src="/ZzzjhBlog/./%E5%86%85%E9%83%A8%E7%B1%BB/image-20240908001932800.png" alt="image-20240908001932800"></p><h4 id="匿名内部类的注意事项和使用细节"><a href="#匿名内部类的注意事项和使用细节" class="headerlink" title="匿名内部类的注意事项和使用细节"></a>匿名内部类的注意事项和使用细节</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousInnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        outer.f1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123; <span class="comment">//外部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//创建一个基于类的匿名内部类</span></span><br><span class="line">       <span class="comment">//此时 编译类型为 Person  运行类型为 Outer$1</span></span><br><span class="line">       <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;匿名内部类重写了 hi()方法&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="comment">//此时调用方法  由于jdk动态绑定机制 看运行型类型方法 所以调用的是Outer$1重写的hi()方法</span></span><br><span class="line">       <span class="comment">//如果没有 匿名内部类Outer$1没有重写hi()方法 那么就会找到Person的hi()方法</span></span><br><span class="line">       person.hi();</span><br><span class="line">       <span class="comment">//也可以直接调用 如下</span></span><br><span class="line">       <span class="comment">//在创建一个匿名内部类</span></span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Person</span>()&#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;匿名内部类重写hi()方法 哈哈哈哈&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ok</span><span class="params">(String str)</span> &#123;</span><br><span class="line">               <span class="built_in">super</span>.ok(str);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;.ok(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">       <span class="comment">//这段可以这么理解</span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        new Person()&#123;</span></span><br><span class="line"><span class="comment">           @Override</span></span><br><span class="line"><span class="comment">           public void hi() &#123;</span></span><br><span class="line"><span class="comment">               System.out.println(&quot;匿名内部类重写hi()方法 哈哈哈哈&quot;);</span></span><br><span class="line"><span class="comment">           &#125;</span></span><br><span class="line"><span class="comment">           @Override</span></span><br><span class="line"><span class="comment">           public void ok(String str) &#123;</span></span><br><span class="line"><span class="comment">               super.ok(str);</span></span><br><span class="line"><span class="comment">           &#125;</span></span><br><span class="line"><span class="comment">       &#125;</span></span><br><span class="line"><span class="comment">       这一段就是一个对象 因为匿名内部类本身也是返回对象 所以可以调用方法 也可以传参数</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person hi()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ok</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person ok() &quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><img src="/ZzzjhBlog/./%E5%86%85%E9%83%A8%E7%B1%BB/image-20240908004314132.png" alt="image-20240908004314132"></p><h3 id="匿名内部类实践"><a href="#匿名内部类实践" class="headerlink" title="匿名内部类实践"></a>匿名内部类实践</h3><p><strong>练习一</strong></p><p><strong>匿名内部类可以当作实参直接传递</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClassExercise01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//匿名内部类当作实参直接传递 简介高效</span></span><br><span class="line">        f1(<span class="keyword">new</span> <span class="title class_">A</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;这是一副名画&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 传统方式需要定义一个类来实现接口 A，并且实现接口方法，</span></span><br><span class="line">        <span class="comment">// 然后创建该类对象并传递给方法。</span></span><br><span class="line">        <span class="comment">// 相比之下，匿名内部类的方式显得更加简洁高效。</span></span><br><span class="line">        <span class="comment">// 另一个优点是，匿名内部类每次创建的实例都是独立的，</span></span><br><span class="line">        <span class="comment">// 修改某个实例的行为不会影响其他地方的实现，</span></span><br><span class="line">        <span class="comment">// 而如果使用的是显式定义的类，修改类的实现可能会影响所有使用该类的地方。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态方法，形参列表（接口类型）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(A a)</span> &#123;</span><br><span class="line">        a.cry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>练习二</strong><br>要求：<br>1.有一个铃声接口Bell，里面有个ring方法<br>2.有一个手机类Cellphone，具有闹钟功能,alarmclock，参数是Bell类型<br>3.,测试手机类的闹钟功能，通过匿名内部类,（对象）作为参数，打印：懒猪起床了<br>4.再传入另一个匿名内部类（对象），打印：小伙伴上课了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClassExercise02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CellPhone</span> <span class="variable">cellPhone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CellPhone</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1. 传递的是实现了Bell的接口的匿名内部类</span></span><br><span class="line">        <span class="comment">//2. 重写了 ring</span></span><br><span class="line">        <span class="comment">//3. 相当于接收了</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        new Bell() &#123;</span></span><br><span class="line"><span class="comment">            <span class="doctag">@Override</span></span></span><br><span class="line"><span class="comment">            public void ring() &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(&quot;懒猪起床了&quot;);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//这样这个参数的编译类型是Bell接口 运行类型是匿名内部类</span></span><br><span class="line">        cellPhone.alarmClock(<span class="keyword">new</span> <span class="title class_">Bell</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ring</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;懒猪起床了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="comment">//这里有创建了一个 匿名内部类和上面的匿名内部类不是一个 类 但是 运行过程和上面相同</span></span><br><span class="line">        cellPhone.alarmClock(<span class="keyword">new</span> <span class="title class_">Bell</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ring</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;小伙伴上课了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bell</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">ring</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CellPhone</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">alarmClock</span><span class="params">(Bell bell)</span>&#123;</span><br><span class="line">        bell.ring(); <span class="comment">//动态绑定 回到运行类型的ring()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>描述：</p><p>成员内部类定义在外部类的成员位置，并且没有static修饰<br>1.可以访问外部类的所有成员 （包括私有的）<br>2**.可以添加任意访问修饰符**（public、protected、默认、private），因为它的地位是一个成员<br><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemberInnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer01</span> <span class="variable">outer01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer01</span>();</span><br><span class="line">        outer01.f1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer01</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="comment">//注意成员内部类是定义在外部类的成员位置上</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner01</span>&#123; <span class="comment">//成员内部类</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Outer01 的 n1 &quot;</span> + n1 + <span class="string">&quot; Outer01 的 name&quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Inner01</span> <span class="variable">inner01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner01</span>();</span><br><span class="line">        inner01.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.作用域：和外部类的其他成员一样 作用域为外部类的整个类体<br>4.成员内部类—访问—-外部成员 比如（属性、方法）【访问方式 直接访问】<br>5.外部类—访问—成员内部类 【访问方式：创建对象 访问】<br>6.外部其他类—访问—-&gt;成员内部类<br>7.如果外部类和局部内部类的成员重名时候，默认遵守就近原则。如果想访问外部类的成员，则可以使用（<strong>外部类名.this.成员</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//外部其他类 使用成员内部类的三种方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemberInnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建内部类实例：首先，你需要创建外部类的实例，然后通过这个实例来创建内部类的实例。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">        Outer01.<span class="type">Inner01</span> <span class="variable">inner01</span> <span class="operator">=</span> outer01.<span class="keyword">new</span> <span class="title class_">Inner01</span>();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer01</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="comment">//注意成员内部类是定义在外部类的成员位置上</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner01</span>&#123; <span class="comment">//成员内部类</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Outer01 的 n1 &quot;</span> + n1 + <span class="string">&quot; Outer01 的 name&quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Inner01</span> <span class="variable">inner01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner01</span>();</span><br><span class="line">        inner01.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>介绍</p><p>1.可以直接访问外部类的所有静态成员，包含私有的，但是不能直接访问非静态的成员<br>2**.可以添加任意访问修饰符**（public、protected、默认、private），因为它的地位是一个成员<br>3.作用域：和外部类的其他成员一样 作用域为外部类的整个类体<br>4.静态内部类—-访问——-&gt;外部类（比如：静态属性）【访问方式： 直接访问所有静态成员】<br>5.外部类—–访问——-&gt;静态内部类 访问方式【创建对象 再访问】<br>6.外部其他类——访问——-&gt;静态内部类<br>7.如果外部类和局部内部类的成员重名时候，默认遵守就近原则。如果想访问外部类的成员，则可以使用（<strong>外部类名.this.成员</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer02</span> <span class="variable">outer02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer02</span>();</span><br><span class="line">        outer02.m1();</span><br><span class="line">        <span class="comment">//因为静态内部类，可以通过类名直接访问（前提满足访问权限）</span></span><br><span class="line">        Outer02.<span class="type">Inner02</span> <span class="variable">inner02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer02</span>.Inner02();</span><br><span class="line">        inner02.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer02</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;李四&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1使用static 修饰</span></span><br><span class="line">    <span class="comment">//可以访问外部类的所有静态成员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner02</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Inner02</span> <span class="variable">inner02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner02</span>();</span><br><span class="line">        inner02.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="知识点练习"><a href="#知识点练习" class="headerlink" title="知识点练习"></a>知识点练习</h2><h3 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a><strong>练习1</strong></h3><p>1.计算器接口具有work方法 功能是运算 有一个手机类Cellphone<br>定义方法testWork测试计算功能调用接口的work方法<br>2.调用Cellphone对象的testWork方法 使用上 匿名内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Practice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Cellphone</span> <span class="variable">cellphone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cellphone</span>();</span><br><span class="line">        cellphone.testWork(<span class="keyword">new</span> <span class="title class_">Calculate</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">work</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> a + b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">10</span>,<span class="number">15</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Calculate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">work</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cellphone</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWork</span><span class="params">(Calculate calculate,<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">        System.out.println(calculate.work(a,b)); <span class="comment">//根据动态绑定规则 它的 编译类型是Calculate  运行类型是 匿名内部类 所以调用 匿名内部类的testWork()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>解析：</strong></p><p>这段代码就是 在 Cellphone 类中定义了testWork()方法 形参列表是（<strong>Calculate接口，整数 a，整数 b</strong>）然后我们在主方法中 创建CeLLphone 对象实例然后调用testWork()方法 参数是用 <strong>匿名内部类形式（匿名内部类同时也是一个对象） 传了一个 实现了Calculate 的实现类进去</strong> 还有 整数 a 和整数b  然后再testWork()方法中 <strong>局部变量calculate 就是我们传入的 实现了Calculate接口的匿名内部类</strong>  然后<strong>调用这个 实现类重写的 work()方法</strong> 。</p><h3 id="练习2"><a href="#练习2" class="headerlink" title="练习2"></a><strong>练习2</strong></h3><p>1.编写一个类A 在类中定义局部内部类B ,B中有一个私有常量name，有一个方法show（）打印常量name 进行测试<br>2.进阶：A中 也定义一个私有变量name，在show（）方法中打印测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;外部类A的name&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">            <span class="keyword">private</span>  <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;局部内部类B的name&quot;</span>;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String name)</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;局部内部类name: &quot;</span> + name);</span><br><span class="line">                System.out.println(<span class="string">&quot;外部类name: &quot;</span> + A.<span class="built_in">this</span>.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        b.show(b.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        a.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="练习3"><a href="#练习3" class="headerlink" title="练习3"></a><strong>练习3</strong></h3><p>有一个Car类 有属性temperature（温度） 车内有Air（空调）类，有吹风功能flow  Air会监视车内的温度 如果超过40度吹冷气 低于0度吹暖气 如果在这之间则关掉空调  实例化 具有不同温度的Car对象 调用空调的flow方法 测试空条吹的风是否正确</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Practice3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Car</span> <span class="variable">car1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="number">41</span>);</span><br><span class="line">        <span class="type">Car</span> <span class="variable">car2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">Car</span> <span class="variable">car3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="number">20</span>);</span><br><span class="line">         car1.<span class="keyword">new</span> <span class="title class_">Air</span>().flow();</span><br><span class="line">         car2.<span class="keyword">new</span> <span class="title class_">Air</span>().flow();</span><br><span class="line">         car3.<span class="keyword">new</span> <span class="title class_">Air</span>().flow();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="type">double</span> temperature;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Air</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flow</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (Car.<span class="built_in">this</span>.temperature &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;吹暖气&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Car.<span class="built_in">this</span>.temperature &gt;= <span class="number">40</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;吹冷气&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;关闭空调&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(<span class="type">double</span> temperature)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/ZzzjhBlog/2025/03/31/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/ZzzjhBlog/2025/03/31/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>类的理解</strong><br>类就是对现实事物的一种描述</p><p><strong>类的组成</strong><br>属性: 指事物的特征，例如：手机事物 (品牌，价格，尺寸)<br>行为: 指事物能执行的操作，例如：手机事物 (打电话，发短信)</p><p>类和对象的关系<br>类是对事物的一种描述，对象则为具体存在的事物</p><p>**类的五大要素：**属性、方法、构造器、代码块、内部类</p><h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &#123;  </span><br><span class="line">    <span class="comment">// 成员变量  </span></span><br><span class="line">    变量<span class="number">1</span>的数据类型 变量<span class="number">1</span>;  </span><br><span class="line">    变量<span class="number">2</span>的数据类型 变量<span class="number">2</span>;  </span><br><span class="line">    ...  </span><br><span class="line">    <span class="comment">// 成员方法  </span></span><br><span class="line">    方法<span class="number">1</span>;  </span><br><span class="line">    方法<span class="number">2</span>; </span><br><span class="line">    <span class="comment">//内部类</span></span><br><span class="line">    class 内部类名&#123;</span><br><span class="line">        <span class="comment">//内部类的属性、方法、构造器等等</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        代码；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//无参数构造器</span></span><br><span class="line">    <span class="keyword">public</span> 类名()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有参数构造器</span></span><br><span class="line">    <span class="keyword">public</span> 类名(XXX XXX)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a>对象的使用</h3><p>创建对象<br>格式: 类名 对象名 &#x3D; new 类名();<br>范例: Phone p &#x3D; new Phone();</p><p>使用对象</p><ol><li>使用成员变量<br>格式: 对象名.变量名</li><li>使用成员方法<br>格式: 对象名.方法名()</li></ol><h3 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h3><p>比如现在有一个类Cat 我创建它的实例对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OOP01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;小白&quot;</span>,<span class="number">12</span>);</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;小黑&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在JVM内存中是这样的<br><img src="/ZzzjhBlog/./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240913010328249.png" alt="image-20240913010328249"></p><h3 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h3><p>成员变量和局部变量的区别</p><ol><li>变量位置不同: 成员变量 (类中方法外) 局部变量 (方法内部或方法声明上)</li><li>存在中位置不同: 成员变量 (堆内存) 局部变量 (栈内存)</li><li>生命周期不同: 成员变量 (随着对象的存在而存在, 随着对象的消失而消失) 局部变量 (随着方法的调用而存在, 随着方法的调用完毕而消失)</li><li>初始化值不同: 成员变量 (有默认初始化值) 局部变量 (没有默认初始化值, 必须先定义, 赋值才能使用)</li></ol><h3 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h3><p>如果局部跟全局变量名冲突优先使用局部 &#x3D;&gt; 就近原则<br>调用 this 所在的方法, this 就是 当前对象</p><p>this 修饰的变量用于指代成员变量, 其主要作用是 (区分局部变量和成员变量的重名问题)<br>方法的形参如果与成员变量同名, 不带 this 修饰的变量指的是形参, 而不是成员变量<br>方法的形参如果与成员变量同名, 不带 this 修饰的变量指的是成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小黄人&quot;</span>, <span class="number">19</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;神偷奶爸&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        p1.method(p2.getName(),p2.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">nationality</span> <span class="operator">=</span> <span class="string">&quot;中国&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//this 修饰的变量用于指代成员变量, 其主要作用是 (区分局部变量和成员变量的重名问题)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我叫 &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;我的年龄是 &quot;</span> + <span class="built_in">this</span>.age + <span class="string">&quot; 岁 &quot;</span>+  name +<span class="string">&quot; 的年龄是 &quot;</span> + age + <span class="string">&quot; 岁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a><strong>构造方法</strong></h3><ol><li>构造方法是一种特殊的方法</li><li>构造方法没有返回值 连返回值的位置都没有</li><li>构造方法的方法名就是类名</li><li>构造方法可以有参数 也可以没有参数</li><li>构造方法可以重载</li><li>如果没有给自己定义构造方法, 系统会默认提供一个空参数构造方法<br>如果自定义了构造方法, 系统将不提供默认的无参数构造方法<br>(建议: 如果自定义了构造方法, 最好加上无参构造)</li><li>构造方法的作用? 他是在创建对象的时候成员变量进行赋值 &#x3D;&gt; 创建对象的时候 构造只执行一次</li></ol><p><img src="/ZzzjhBlog/./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240914155238011.png" alt="image-20240914155238011"></p><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小黄人&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="comment">//被static 修饰的方法或者属性 都是属于类的</span></span><br><span class="line">        <span class="comment">//使用static关键字修饰的属性或者方法 调用方式是 类名.属性名 或者类名.方法名</span></span><br><span class="line">        System.out.println(Person.nationality);</span><br><span class="line">        System.out.println(Person.getNationality());</span><br><span class="line">        <span class="comment">//也可以使用对象的实例来调用(当然 不建议这么调用 static修饰属性或者方法都推荐使用 类名.属性/方法 去调用)</span></span><br><span class="line">        System.out.println(p1.nationality);</span><br><span class="line">        System.out.println(p1.getNationality());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">nationality</span> <span class="operator">=</span> <span class="string">&quot;中国&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getNationality</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nationality;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="什么是类变量"><a href="#什么是类变量" class="headerlink" title="什么是类变量"></a>什么是类变量</h3><p>类变量也叫静态变量&#x2F;静态属性，是该类所有对象共享的变量，任何一个该类对象去访问它的时候，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的时同一个变量。</p><h3 id="如何定义类变量"><a href="#如何定义类变量" class="headerlink" title="如何定义类变量"></a>如何定义类变量</h3><p><strong>语法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">static</span> 数据类型 变量名 <span class="comment">//推荐这种方法</span></span><br><span class="line"><span class="keyword">static</span> 访问修饰符 数据类型 变量名</span><br></pre></td></tr></table></figure><p><strong>如何访问</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类名.变量名 <span class="comment">//推荐</span></span><br><span class="line">对象名.类变量名</span><br></pre></td></tr></table></figure><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p>类方法也叫静态方法</p><p><strong>语法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">static</span> 数据返回类型 方法名()&#123;&#125;推荐</span><br><span class="line"><span class="keyword">static</span> 访问修饰符 数据返回类型 方法名()&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>如何调用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类名.方法名 <span class="comment">//推荐</span></span><br><span class="line">对象名.方法名</span><br></pre></td></tr></table></figure><p>当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率,比如：工具类中的方法utils,Math类、Arrays类、Collections集合类看下源码：,&gt;小结,在程序员实际开发，往往会将一些通用的方法，设计成静态方法，这样我们不需要创建对象就可以使用,比如打印一维数组</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>1）类方法中无this的参数,普通方法中隐含着this的参数,<br>2）类方法可以通过类名调用，也可以通过对象名调用。<br>3）普通方法和对象有关，需要通过对象名调用，比如对象名.方法名（参数），不能通过类名调用<br>4）<strong>类方法中不允许使用和对象有关的关键字，比如this和super。普通方法（成员方法）可以可以使用和对象有关的关键字</strong><br>5）类方法（静态方法）中只能访问静态变量或静态方法。<br>6）普通成员方法，既可以访问非静态成员，也可以访问静态成员。<br><strong>小结：静态方法，只能访问静态的成员，非静态的方法，可以访问静态成员和非静态成员,（必须遵守访问权限）</strong></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="为什么需要继承"><a href="#为什么需要继承" class="headerlink" title="为什么需要继承"></a><strong>为什么需要继承</strong></h3><p>解决重复代码多、难以维护的问题<br><strong>目的</strong><br>代码重用、简化系统、减轻负担<br><strong>手段方法</strong><br>抽取共同的属性和方法 让子类继承</p><p><strong>使用细节：</strong><br>①子类<strong>继承了父类的所有属性和方法</strong>但是<strong>私有属性和方法不能在 子类中直接使用 要使用 公共方法间接的访问</strong> 子类只<strong>能直接使用非私有的属性和方法</strong><br><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Extends01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        System.out.println(son.getM());<span class="comment">//子类想要获取父类的私有属性 就要使用父类提供的共有方法来间接访问父类的私有属性</span></span><br><span class="line">        son.f2(); <span class="comment">//子类想要使用父类的 私有方法 也需要 父类提供共有方法 间接的去调用父类的私有方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123; <span class="comment">//父类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的f1 私有方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span>&#123;</span><br><span class="line">        f1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getM</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123; <span class="comment">//子类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>② <strong>子类必须调用父类的构造器 完成父类的初始化</strong></p><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Extends02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的无参数构造器执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(); <span class="comment">//默认调用父类的无参数构造器 super(); 就算你没写 也默认有</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③当创建子类对象时候 <strong><font color='Rhodamine '>不管使用哪个子类的构造器 子类总是默认调用父类的无参数构造器完成父类的初始化</font></strong> 如果**<font color='Rhodamine '>父类没有提供无参数构造器</font>** 那么在子类的构造器中**<font color='Rhodamine '>必须用super取指定调用父类的构造器取完成父类的初始化</font>** 否则编译不会通过<br><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Extends02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的有参数构造器执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="comment">//父类中没有 无参数构造器  那么就必须要指定调用父类的哪个构造器</span></span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>④如果希望显示的调用父类的构造器那么可以这样：super()&#x2F;&#x2F;参数列表</p><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Extends03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">23</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的无参数构造器执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的有参数构造器执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">    <span class="comment">//super() 显示的调用父类的构造器</span></span><br><span class="line">        <span class="built_in">super</span>(name,age); <span class="comment">//显示的调用父类的构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>⑤super在使用的时候需要放在构造器第一行</strong><br><strong>⑥super()和this()都只能放在构造器第一行 因此这两个方法不能存在于一个构造方法内</strong>**<br>⑦java所有的类都是 Object 的子类 可以调用Object 的公共方法<br>⑧java 构造器的调用不限于直接父类 会一直追溯到Object类（顶级父类）<br><strong>⑨java中 类只能实现单继承 如果要实现 c 继承 b 继承 a 那么 可以让 c 继承b  让b 继承 a那么c就继承a</strong></p><p><strong>示例</strong><br>这个例子也展示了 注意事项的 第⑧个 和第⑨个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Extends03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A的无参数构造器被调用&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B的无参数构造器被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">C</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;C的无参数构造器被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出顺序 A的无参数构造器 -&gt; B的无参数构造器 -&gt; C的无参数构造器</span></span><br></pre></td></tr></table></figure><h3 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h3><p>如果父类的方法不能够满足子类的要求的话 子类可以重写这个方法 来满足自己的需要<br>当然也可以</p><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>被修饰的 变量不能被修改<br>被修饰的 方法不能被重写<br>被修饰的 类不能被继承</p><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p><strong>好处&#x2F;细节</strong><br>①调用父类构造器的好处是（分工明确，父类属性由父类初始化，子类属性由子类初始化）<br>②当子类中有和父类中的成员（属性或方法）<strong>重名的时候，为了访问父类成员，必须通过super</strong>。如果<strong>没有重名，使用super、this 直接访问</strong>是一样的效果</p><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Extends01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        <span class="comment">//此时子类中由和父类重名的方法 那么优先调用子类的</span></span><br><span class="line">        <span class="comment">//如果 我把子类的f1 方法注释掉 那么只有父类 有f1方法 就调用父类的</span></span><br><span class="line">        son.f1();</span><br><span class="line">        <span class="comment">//如果父类和子类中都有 f1 方法 那么我想在子类中调用父类的 f1方法 那么就需要使用 super 关键字 【super.方法名】 来调用父类的f1方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的 f1方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">    public void f1() &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;B类的f1方法&quot;);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查找  <strong>f1方法</strong>的顺序是:<br>①先查找本类中有没有 有则调用<br>②没有 则找父类（如果有 并且可以调用 则调用）<br>③<strong>如果父类没有 那么就继续找 父类的父类 一直这样 直到找到 Object类（顶级父类）</strong><br>如果整个过程找到了 不能访问 则报错<br>如果整个过程没找到 则提示方法不存在</p><p>③super的访问<strong>不限于 直接父类 如果 爷爷类和本类中有同名的成员 也可以使用super访问</strong>爷爷类的成员 如果<strong>父类和爷爷类中都有 同名成员 那么遵循就近原则</strong></p><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Extends01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        son.f1(); <span class="comment">//父类和爷爷类 都有 遵循就近原则 访问父类的f1方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandFather</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;爷爷类的 f1方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> <span class="keyword">extends</span> <span class="title class_">GrandFather</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的 f1方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">    public void f1() &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;B类的f1方法&quot;);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/ZzzjhBlog/./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240919222237379.png" alt="image-20240919222237379"></p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><p>①一个对象的编译类型和运行类型可以不一致<br>②编译类型在定义对象时，就确定了，不能改变<br>③运行类型是可以变化的<br>④编译类型看定义时  &#x3D; 的左边，运行类型 看 &#x3D; 的右边</p><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyObject01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//animal1 的编译类型是Animal  运行类型是 Cat</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        animal1.cry(); <span class="comment">//运行时，这是执行到该行时 运行类型时 Cat 那么调用cry方法 就会找Cat 的cry()方法</span></span><br><span class="line">        <span class="comment">//animal1 的编译类型是Animal  运行类型是 Dog</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        animal2.cry(); <span class="comment">//这个和上面一样 运行类型时 Dog 那么调用cry方法 就会找Dog 的cry()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal cry() 动物在叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat cry() 猫在叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog cry() 狗在叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/ZzzjhBlog/./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240919223423463.png" alt="image-20240919223423463"></p><h3 id="多态的注意事项和细节"><a href="#多态的注意事项和细节" class="headerlink" title="多态的注意事项和细节"></a>多态的注意事项和细节</h3><p>多态的前提是：两个类存在继承关系</p><h4 id="多态的向上转型"><a href="#多态的向上转型" class="headerlink" title="多态的向上转型"></a>多态的向上转型</h4><p>①本质：父类的引用指向了子类的对象<br>②语法：父类类型  引用名 &#x3D; new 子类类型()；<br>③特点：编译看左边 运行看右边<br>  可以调用父类中的所有成员【要遵守访问权限】<br>  不能调用子类中特有成员<br>  最终运行效果看子类的具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyObject01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        animal.catchMouse(); <span class="comment">//此时会报错 因为这个catchMouse 是子类的特有方法 因为在编译阶段能调用的成员 是由编译类型决定的</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal cry() 动物在叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat cry() 猫在叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchMouse</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抓老鼠&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="多态的向下转型"><a href="#多态的向下转型" class="headerlink" title="多态的向下转型"></a>多态的向下转型</h4><p>①语法：子类类型 引用名 &#x3D; （子类类型） 父类引用；<br><strong>②只能强行转换 父类的应用 不能强行转换父类的对象</strong><br><strong>③要求父类的引用必须指向的是当前目标类型的对象</strong><br>④ 强转后 可以调用子类类型中所有的成员</p><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyObject01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        animal.catchMouse(); <span class="comment">//此时会报错 因为这个catchMouse 是子类的特有方法 因为在编译阶段能调用的成员 是由编译类型决定的</span></span><br><span class="line">        <span class="comment">//向下转型 如果要调用子类中的特有方法 需要向下转型</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat) animal; <span class="comment">//此时编译类型 和 运行类型 都是Cat</span></span><br><span class="line">        cat.catchMouse(); <span class="comment">//此时就能调用子类中的特有方法</span></span><br><span class="line">        <span class="comment">//但是这样写不行 因为 父类的引用必须指向的是当前目标类型的对象 就是一开始 你的 编译类型是 Animal 运行类型是 Cat  那么这时候 向下转型 需要的是 当初 运行类型的对象 Cat cat = (Cat) animal;</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) animal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal cry() 动物在叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat cry() 猫在叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchMouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抓老鼠&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性没有重写的说法 属性的值看 编译类型<br><strong>instance Of 比较操作符，可以用来判断对象的运行类型是否为（XX类型或者XX类型的子类型）</strong></p><p><strong>练习题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyObject01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        System.out.println(son.count);</span><br><span class="line">        son.display();</span><br><span class="line">        <span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> son;</span><br><span class="line">        System.out.println(father == son);</span><br><span class="line">        System.out.println(father.count);</span><br><span class="line">        father.display();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//求输出的结果</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123; <span class="comment">//父类</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123; <span class="comment">//子类</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析：</strong><br>首先创建 Son类型的对象 然后son对象中有父类的count 和子类的count 值分别是 10和20。</p><p> <strong>s.count</strong> 这个是访问属性 <strong>访问属性 看编译类型</strong> 此时编译类型是 Son 那么s.count就是20。</p><p> 然后就是 <strong>s.display()</strong> 此时调用方法 如果是 <strong>调用方法那么就是 看运行类型</strong>  此时运行类型是 Son，那么 s.display()中 输出 this.count 就是当前对象的 count 那么就是 20。</p><p>接下来是  <strong>Father father &#x3D; son;</strong> 此时 发生了**向上转型，向上转型结束后 此时的 编译类型是Father 运行类型是 Son **。 </p><p>接下来 **System.out.println(father &#x3D;&#x3D; son); **它们都指向同一个对象 所以输出trye</p><p>然后  <strong>father.count</strong>  这个是<strong>访问属性 看编译类型</strong> 而<strong>此时编译类型 是Father</strong> 那么 father.count 就是 10。</p><p>最后 <strong>faher.display()</strong> 这里是调用方法 此时的运行类型还是 Son 那就是调用 Son中的 display 方法。 this.count  this就是本身这个对象 所以 this.count 是20</p><p><strong>运行结果</strong><br><img src="/ZzzjhBlog/./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240919232948433.png" alt="image-20240919232948433"></p><p><strong>java 动态绑定机制！！！！</strong></p><p>①<strong>当调用方法对象的时候</strong> 该<strong>方法会和该对象的内存地址&#x2F;运行类型绑定</strong><br>②<strong>当调用对象属性时</strong>，没有动态绑定机制，<strong>哪里声明，哪里使用</strong></p><p><strong>题目</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyObject01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        System.out.println(father.sum());</span><br><span class="line">        System.out.println(father.sum1());</span><br><span class="line">        <span class="comment">//求输出的结果</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123; <span class="comment">//父类</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getI() + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getI</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123; <span class="comment">//子类</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">    public int sum() &#123;</span></span><br><span class="line"><span class="comment">        return i + 20;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getI</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>father.sum();</strong>    father <strong>编译类型是 Father</strong>  <strong>运行类型是 Son</strong>  <strong>调用方法 触发动态绑定机制</strong>   <strong>调用方法 看 运行类型</strong> 此时 Son中 sum 方法被注释掉  那么就会 向它的父类 Father 查找有没有 sum方法 结果 有 然后 <strong>执行 return getI() + 10;</strong>  又**发现 要调用 getI()方法 此时又触发动态绑定机制 **调用方法 看运行类型 <strong>那么调用的就是 运行类型 Son 的 getI()方法</strong> 获得 i的值 为 20；最终 输出 30；<br>然后下一个 <strong>father.sum1();</strong>  <strong>触发动态绑定机制  调用方法 看 运行类型</strong>  Son中 有sum1()方法<br>然后 i + 10 此时 i  在 Son 中声明了 那么就用 Son中 i 的值 20 .最后结果为 30；</p><p><strong>运行结果</strong><br><img src="/ZzzjhBlog/./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240919234815441.png" alt="image-20240919234815441"></p><p><strong>改动题目</strong><br>将 子类的 sum1 也注释掉那么输出什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyObject01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        System.out.println(father.sum1());</span><br><span class="line">        <span class="comment">//求输出的结果</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123; <span class="comment">//父类</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getI() + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getI</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123; <span class="comment">//子类</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">    public int sum() &#123;</span></span><br><span class="line"><span class="comment">        return i + 20;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">    public int sum1() &#123;</span></span><br><span class="line"><span class="comment">        return i + 10;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getI</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析</strong><br>father.sum()   father <strong>编译类型是 Father</strong>  <strong>运行类型是 Son</strong>  <strong>调用方法 触发动态绑定机制</strong>   <strong>调用方法 看 运行类型</strong>  此时 Son中 sum1 方法被注释掉  那么就会 向它的父类 Father 查找有没有 sum1 方法 结果 有 那就执行Father 的sum1方法   <strong>return i + 10;</strong>  此时 i 在 Father 类中声明了 那么就是用 Father 中 i 的值 那就是 10； 最后返回结果时 20；</p><p><strong>运行结果：</strong><br><img src="/ZzzjhBlog/./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240919235229646.png" alt="image-20240919235229646"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
